/**
 * @file Firestore Security Rules for ScholarSphere
 * @description This ruleset enforces a strict user-ownership model, where users can only access data under their own user ID.
 *
 * Data Structure:
 * All data is nested under /users/{userId}, including profile information, timetable entries, assignments, exams, attendance records, attendance statistics, and analytics data.
 *
 * Key Security Decisions:
 * - Users can only read and write their own data.
 * - Listing of user documents is disallowed to prevent enumeration.
 * - All subcollections enforce ownership via the userId field within the document.
 * - Data consistency is enforced by validating the userId on create and update operations to match the document path.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Checks if the request is authenticated.
     * @return {bool} True if the request is authenticated, false otherwise.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the authenticated user ID matches the provided user ID.
     * @param {string} userId The user ID to compare against.
     * @return {bool} True if the user is the owner, false otherwise.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * @description Checks if the authenticated user is the owner of an existing document.
     * @param {string} userId The user ID to compare against.
     * @return {bool} True if the user is the owner and the document exists, false otherwise.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * @description Security rules for the /users/{userId} collection.
     * @path /users/{userId}
     * @allow (create) Authenticated user with matching UID can create their own document.
     * @deny (create) Authenticated user cannot create a document with a mismatched UID.
     * @allow (get) Authenticated user can read their own document.
     * @deny (get) Authenticated user cannot read another user's document.
     * @allow (update) Authenticated user can update their own document.
     * @deny (update) Authenticated user cannot update another user's document.
     * @allow (delete) Authenticated user can delete their own document.
     * @deny (delete) Authenticated user cannot delete another user's document.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;

      allow create: if isOwner(userId) && request.resource.data.uid == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.uid == resource.data.uid;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Security rules for the /users/{userId}/timetable/{timetableId} collection.
     * @path /users/{userId}/timetable/{timetableId}
     * @allow (create) Authenticated user with matching UID can create a timetable entry in their own document.
     * @deny (create) Authenticated user cannot create a timetable entry with a mismatched UID.
     * @allow (get) Authenticated user can read their own timetable entry.
     * @deny (get) Authenticated user cannot read another user's timetable entry.
     * @allow (update) Authenticated user can update their own timetable entry.
     * @deny (update) Authenticated user cannot update another user's timetable entry.
     * @allow (delete) Authenticated user can delete their own timetable entry.
     * @deny (delete) Authenticated user cannot delete another user's timetable entry.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId}/timetable/{timetableId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);

      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Security rules for the /users/{userId}/assignments/{assignmentId} collection.
     * @path /users/{userId}/assignments/{assignmentId}
     * @allow (create) Authenticated user with matching UID can create an assignment in their own document.
     * @deny (create) Authenticated user cannot create an assignment with a mismatched UID.
     * @allow (get) Authenticated user can read their own assignment.
     * @deny (get) Authenticated user cannot read another user's assignment.
     * @allow (update) Authenticated user can update their own assignment.
     * @deny (update) Authenticated user cannot update another user's assignment.
     * @allow (delete) Authenticated user can delete their own assignment.
     * @deny (delete) Authenticated user cannot delete another user's assignment.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId}/assignments/{assignmentId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);

      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Security rules for the /users/{userId}/exams/{examId} collection.
     * @path /users/{userId}/exams/{examId}
     * @allow (create) Authenticated user with matching UID can create an exam in their own document.
     * @deny (create) Authenticated user cannot create an exam with a mismatched UID.
     * @allow (get) Authenticated user can read their own exam.
     * @deny (get) Authenticated user cannot read another user's exam.
     * @allow (update) Authenticated user can update their own exam.
     * @deny (update) Authenticated user cannot update another user's exam.
     * @allow (delete) Authenticated user can delete their own exam.
     * @deny (delete) Authenticated user cannot delete another user's exam.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId}/exams/{examId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);

      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Security rules for the /users/{userId}/attendance/{attendanceId} collection.
     * @path /users/{userId}/attendance/{attendanceId}
     * @allow (create) Authenticated user with matching UID can create attendance in their own document.
     * @deny (create) Authenticated user cannot create attendance with a mismatched UID.
     * @allow (get) Authenticated user can read their own attendance.
     * @deny (get) Authenticated user cannot read another user's attendance.
     * @allow (update) Authenticated user can update their own attendance.
     * @deny (update) Authenticated user cannot update another user's attendance.
     * @allow (delete) Authenticated user can delete their own attendance.
     * @deny (delete) Authenticated user cannot delete another user's attendance.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId}/attendance/{attendanceId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);

      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Security rules for the /users/{userId}/attendanceStats collection.
     * @path /users/{userId}/attendanceStats
     * @allow (create) Authenticated user with matching UID can create attendanceStats in their own document.
     * @deny (create) Authenticated user cannot create attendanceStats with a mismatched UID.
     * @allow (get) Authenticated user can read their own attendanceStats.
     * @deny (get) Authenticated user cannot read another user's attendanceStats.
     * @allow (update) Authenticated user can update their own attendanceStats.
     * @deny (update) Authenticated user cannot update another user's attendanceStats.
     * @allow (delete) Authenticated user can delete their own attendanceStats.
     * @deny (delete) Authenticated user cannot delete another user's attendanceStats.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId}/attendanceStats {
        allow get: if isOwner(userId);
        allow list: if false;

        allow create: if isOwner(userId) && request.resource.data.userId == userId;
        allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
        allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Security rules for the /users/{userId}/analytics collection.
     * @path /users/{userId}/analytics
     * @allow (create) Authenticated user with matching UID can create analytics in their own document.
     * @deny (create) Authenticated user cannot create analytics with a mismatched UID.
     * @allow (get) Authenticated user can read their own analytics.
     * @deny (get) Authenticated user cannot read another user's analytics.
     * @allow (update) Authenticated user can update their own analytics.
     * @deny (update) Authenticated user cannot update another user's analytics.
     * @allow (delete) Authenticated user can delete their own analytics.
     * @deny (delete) Authenticated user cannot delete another user's analytics.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId}/analytics {
        allow get: if isOwner(userId);
        allow list: if false;

        allow create: if isOwner(userId) && request.resource.data.userId == userId;
        allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
        allow delete: if isExistingOwner(userId);
    }
  }
}